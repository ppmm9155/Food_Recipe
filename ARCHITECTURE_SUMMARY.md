# 최종 정리: Firebase와 Algolia의 완벽한 역할 분담

이 문서는 Food Recipe 앱의 핵심 데이터 아키텍처인 Firebase와 Algolia의 역할 분담을 명확하게 정의합니다.

## 시나리오 1: 사용자가 '검색'을 하지 않을 때 (홈 화면, 검색 초기 화면)

이 시나리오는 사용자가 특정 키워드로 무언가를 적극적으로 '찾기' 전의 모든 상황을 의미합니다. (예: 홈 화면 둘러보기, 검색 탭 초기 진입)

-   **주인공:** ✅ **Firebase**
-   **역할:** 정해진 규칙에 따른 **'정렬'**과 **'추천'**
-   **동작 원리:**
    1.  **안드로이드 앱**이 **Firebase**에게 "요청서(Query)"를 보냅니다.
    2.  **요청서 내용 예시:**
        -   **인기 레시피**: `"recipes" 컬렉션에서, `likeCount`가 높은 순서대로 10개만 정렬해서 줘.`
        -   **최신 레시피**: `"recipes" 컬렉션에서, `createdAt`이 최신인 순서대로 20개만 정렬해서 줘.`
    3.  **Firebase**는 자신의 데이터베이스 안에서 정렬을 수행한 뒤, 완벽하게 정렬된 **최종 결과물만** 앱에게 보냅니다.
    4.  앱은 받은 데이터를 화면에 보여주기만 합니다.

> **결론:** 서버의 강력한 컴퓨팅 파워를 활용하는 가장 효율적인 방법입니다. 앱은 무거운 정렬 계산을 할 필요가 없어 가볍고 빠르게 동작하며, 유지보수에도 압도적으로 유리합니다.

---

## 시나리오 2: 사용자가 '검색'을 실행했을 때

이 시나리오는 사용자가 검색창에 특정 키워드(예: "김치찌개")를 입력하고 검색 버튼을 누른 순간을 의미합니다.

-   **주인공:** ✅ **Algolia**
-   **역할:** 검색어와의 '관련도' 기반 **'랭킹(Ranking)'**
-   **동작 원리:**
    1.  **안드로이드 앱**은 사용자가 입력한 검색어를 **Algolia**에게 보냅니다.
    2.  **Algolia**는 자체 데이터베이스 안에서 데이터를 찾은 뒤, 미리 설정된 **'랭킹 공식'**에 따라 점수를 매겨 순서를 결정합니다.
    3.  **랭킹 공식 예시:**
        -   **1순위:** 검색어가 `title`에 포함되면 가장 높은 점수.
        -   **2순위:** 점수가 비슷하다면, `likeCount` (좋아요 수)가 높은 데이터에 더 높은 점수.
        -   **3순위:** 그래도 순위가 같다면, `createdAt` (최신순)으로 정렬.
    4.  이 모든 점수를 종합하여 가장 관련도 높고 인기 있는 순서대로 완벽하게 정렬된 **최종 결과물**을 앱에 보내줍니다.

> **결론:** Firestore만으로는 구현하기 어려운 '오타 허용', '부분 검색', '복합 랭킹' 기능을 통해 사용자에게 차원이 다른 검색 경험을 제공할 수 있습니다. 검색만큼은 Algolia에게 모든 것을 맡기는 것이 정답입니다.

---

## 두 시스템을 연결하는 숨은 접착제: 데이터 동기화

> **질문:** Algolia가 어떻게 `likeCount` 같은 최신 데이터를 알 수 있는가?
> **답변:** Firebase의 데이터 변경이 생기면, 그 즉시 변경된 데이터를 Algolia에도 알려주어, Algolia가 항상 최신 랭킹 재료를 가지고 있도록 만들어야 합니다.

-   **핵심 도구:** **Firebase Functions**
-   **흐름:**
    1.  사용자가 앱에서 '좋아요'를 누릅니다.
    2.  해당 레시피의 정보가 **Firebase Firestore**에서 업데이트됩니다. (예: `likeCount`: 10 -> 11)
    3.  **Firebase Functions**가 이 변경을 자동으로 감지합니다.
    4.  Functions는 변경된 레시피의 최신 데이터를 통째로 **Algolia**에 보내 덮어쓰기(동기화)합니다.

